//! # DBus interface proxy for: `org.a11y.atspi.Cache`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from DBus introspection data.
//! Source: `Cache.xml`.
//!

use crate::{InterfaceSet, StateSet};
use serde::{Deserialize, Serialize};
use zbus::dbus_proxy;
use zbus::zvariant::{OwnedObjectPath, Type};

#[allow(clippy::module_name_repetitions)]
#[derive(Clone, Debug, Serialize, Deserialize, Type, PartialEq, Eq)]
pub struct CacheItem {
    // The accessible object (within the application)   (so)
    object: (String, OwnedObjectPath),
    // The application (root object(?)    (so)
    app: (String, OwnedObjectPath),
    // The parent object.  (so)
    parent: (String, OwnedObjectPath),
    // The accessbile index in parent.  i
    index: i32,
    // Child count of the accessible  i
    children: i32,
    // The exposed interfece(s) set.  as
    ifaces: InterfaceSet,
    // The short localized name.  s
    short_name: String,
    // Accessible role. u
    role: u32,
    // More detailed localized name.
    name: String,
    // The states applicable to the accessible.  au
    states: StateSet,
}

#[test]
fn zvariant_type_signature_of_cache_item() {
    assert_eq!(
        CacheItem::signature(),
        zbus::zvariant::Signature::from_static_str("((so)(so)(so)iiassusau)").unwrap()
    );
}

// impl CacheItem {
//     fn accessible(&self, conn: &Connection) -> AccessibleProxy<'_> {
//         let conn = conn.inner().connection();
//         let (name, path) = (self.object.0, self.object.1);
//         ProxyBuilder::new(conn)
//     }
// }
//

#[dbus_proxy(interface = "org.a11y.atspi.Cache", assume_defaults = true)]
trait Cache {
    /// GetItems method
    fn get_items(&self) -> zbus::Result<Vec<CacheItem>>;

    /// AddAccessible signal
    #[dbus_proxy(signal)]
    fn add_accessible(&self, node_added: CacheItem) -> zbus::Result<()>;

    /// RemoveAccessible signal
    #[dbus_proxy(signal)]
    fn remove_accessible(&self, node_removed: CacheItem) -> zbus::Result<()>;
}
