diff --git a/atspi-common/src/events/mod.rs b/atspi-common/src/events/mod.rs
index 3b6e091..1abeb33 100644
--- a/atspi-common/src/events/mod.rs
+++ b/atspi-common/src/events/mod.rs
@@ -31,6 +31,7 @@ use zbus_lockstep_macros::validate;
 use zbus_names::{OwnedUniqueName, UniqueName};
 #[cfg(feature = "zbus")]
 use zvariant::OwnedObjectPath;
+use zbus_names::BusName;
 use zvariant::{ObjectPath, OwnedValue, Signature, Type, Value};
 
 use crate::{
@@ -283,7 +284,7 @@ event_test_cases!(LegacyAddAccessibleEvent);
 impl_from_dbus_message!(LegacyAddAccessibleEvent);
 impl_to_dbus_message!(LegacyAddAccessibleEvent);
 
-impl GenericEvent<'_> for LegacyAddAccessibleEvent {
+impl BusProperties<'_> for LegacyAddAccessibleEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Cache:Add";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Cache',member='AddAccessible'";
@@ -326,7 +327,7 @@ impl_from_user_facing_type_for_event_enum!(AddAccessibleEvent, Event::Cache);
 impl_try_from_event_for_user_facing_type!(AddAccessibleEvent, CacheEvents::Add, Event::Cache);
 event_test_cases!(AddAccessibleEvent);
 
-impl GenericEvent<'_> for AddAccessibleEvent {
+impl BusProperties<'_> for AddAccessibleEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Cache:Add";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Cache',member='AddAccessible'";
@@ -349,11 +350,11 @@ impl GenericEvent<'_> for AddAccessibleEvent {
 		self.node_added.clone()
 	}
 }
-impl<'a, T: GenericEvent<'a>> HasMatchRule for T {
-	const MATCH_RULE_STRING: &'static str = <T as GenericEvent>::MATCH_RULE_STRING;
+impl<'a, T: BusProperties<'a>> HasMatchRule for T {
+	const MATCH_RULE_STRING: &'static str = <T as BusProperties>::MATCH_RULE_STRING;
 }
-impl<'a, T: GenericEvent<'a>> HasRegistryEventString for T {
-	const REGISTRY_EVENT_STRING: &'static str = <T as GenericEvent>::REGISTRY_EVENT_STRING;
+impl<'a, T: BusProperties<'a>> HasRegistryEventString for T {
+	const REGISTRY_EVENT_STRING: &'static str = <T as BusProperties>::REGISTRY_EVENT_STRING;
 }
 impl_from_dbus_message!(AddAccessibleEvent);
 impl_to_dbus_message!(AddAccessibleEvent);
@@ -376,7 +377,7 @@ impl_from_user_facing_event_for_interface_event_enum!(
 impl_from_user_facing_type_for_event_enum!(RemoveAccessibleEvent, Event::Cache);
 impl_try_from_event_for_user_facing_type!(RemoveAccessibleEvent, CacheEvents::Remove, Event::Cache);
 event_test_cases!(RemoveAccessibleEvent);
-impl GenericEvent<'_> for RemoveAccessibleEvent {
+impl BusProperties<'_> for RemoveAccessibleEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Cache:Remove";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Cache',member='RemoveAccessible'";
@@ -535,7 +536,7 @@ impl_try_from_event_for_user_facing_type!(
 	Event::Listener
 );
 event_test_cases!(EventListenerDeregisteredEvent);
-impl GenericEvent<'_> for EventListenerDeregisteredEvent {
+impl BusProperties<'_> for EventListenerDeregisteredEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Registry:EventListenerDeregistered";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Registry',member='EventListenerDeregistered'";
@@ -582,7 +583,7 @@ impl_try_from_event_for_user_facing_type!(
 	Event::Listener
 );
 event_test_cases!(EventListenerRegisteredEvent);
-impl GenericEvent<'_> for EventListenerRegisteredEvent {
+impl BusProperties<'_> for EventListenerRegisteredEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Registry:EventListenerRegistered";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Registry',member='EventListenerRegistered'";
@@ -630,7 +631,7 @@ impl TryFrom<Event> for AvailableEvent {
 	}
 }
 event_test_cases!(AvailableEvent);
-impl GenericEvent<'_> for AvailableEvent {
+impl BusProperties<'_> for AvailableEvent {
 	const REGISTRY_EVENT_STRING: &'static str = "Socket:Available";
 	const MATCH_RULE_STRING: &'static str =
 		"type='signal',interface='org.a11y.atspi.Socket',member='Available'";
@@ -725,8 +726,37 @@ impl TryFrom<&zbus::Message> for Event {
 	}
 }
 
+/// Get generic information abbout an event, like its:
+/// 
+/// - dbus member name
+/// - dbus interface name
+/// - dbus path
+/// - dbus sender (bus id)
+///
+/// Member name and interface name combined are unique to individual event types;
+/// dbus path and sender are unique to a specific accessible item available on the accessibility bus (also know as an [`ObjectRef`]).
+/// 
+/// This trait *is* object-safe.
+pub trait GenericEvent {
+	fn member(&self) -> &'static str;
+	fn interface(&self) -> &'static str;
+	fn path(&self) -> ObjectPath<'_>;
+	fn sender(&self) -> BusName<'_>;
+}
+
+assert_obj_safe!(GenericEvent);
+
+impl<T: GenericEvent> From<&T> for ObjectRef {
+	fn from(ev: &T) -> ObjectRef {
+		ObjectRef {
+			name: ev.sender().to_string(),
+			path: ev.path().into(),
+		}
+	}
+}
+
 /// Shared behavior of bus `Signal` events.
-pub trait GenericEvent<'a> {
+pub trait BusProperties {
 	/// The `DBus` member for the event.
 	/// For example, for an [`object::TextChangedEvent`] this should be `"TextChanged"`
 	const DBUS_MEMBER: &'static str;
@@ -742,44 +772,21 @@ pub trait GenericEvent<'a> {
 	const REGISTRY_EVENT_STRING: &'static str;
 
 	/// What is the body type of this event.
-	type Body: Type + Serialize + Deserialize<'a>;
-
-	/// Build the event from the object pair (`ObjectRef` and the Body).
-	///
-	/// # Errors
-	///
-	/// When the body type, which is what the raw message looks like over `DBus`, does not match the type that is expected for the given event.
-	/// It is not possible for this to error on most events, but on events whose raw message [`Self::Body`] type contains a [`enum@zvariant::Value`], you may get errors when constructing the structure.
-	fn build(item: ObjectRef, body: Self::Body) -> Result<Self, AtspiError>
-	where
-		Self: Sized;
-
-	/// Path of the signalling object.
-	fn path(&self) -> ObjectPath<'_>;
-
-	/// Sender of the signal.
-	///
-	/// ### Errors
-	/// - when deserializing the header failed, or
-	/// - When `zbus::get_field!` finds that 'sender' is an invalid field.
-	fn sender(&self) -> String;
-
-	/// The body of the object.
-	fn body(&self) -> Self::Body;
+	type Body: Type + Serialize + for<'b> Deserialize<'b>;
 }
 
 /// A specific trait *only* to define match rules.
 pub trait HasMatchRule {
 	/// A static match rule string for `DBus`.
 	/// This should usually be a string that looks like this: `"type='signal',interface='org.a11y.atspi.Event.Object',member='PropertyChange'"`;
-	/// This should be deprecated in favour of composing the string from [`GenericEvent::DBUS_MEMBER`] and [`GenericEvent::DBUS_INTERFACE`].
+	/// This should be deprecated in favour of composing the string from [`BusProperties::DBUS_MEMBER`] and [`BusProperties::DBUS_INTERFACE`].
 	const MATCH_RULE_STRING: &'static str;
 }
 
 /// A specific trait *only* to define registry event matches.
 pub trait HasRegistryEventString {
 	/// A registry event string for registering for event receiving via the `RegistryProxy`.
-	/// This should be deprecated in favour of composing the string from [`GenericEvent::DBUS_MEMBER`] and [`GenericEvent::DBUS_INTERFACE`].
+	/// This should be deprecated in favour of composing the string from [`BusProperties::DBUS_MEMBER`] and [`BusProperties::DBUS_INTERFACE`].
 	const REGISTRY_EVENT_STRING: &'static str;
 }
 
